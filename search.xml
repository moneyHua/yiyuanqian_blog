<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>语义化版本控制总结</title>
      <link href="/yiyuanqian_blog/2023/08/18/%E8%AF%AD%E4%B9%89%E5%8C%96%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E6%80%BB%E7%BB%93/"/>
      <url>/yiyuanqian_blog/2023/08/18/%E8%AF%AD%E4%B9%89%E5%8C%96%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1>一、语义化版本控制规范</h1><p>语义化版本控制规范（SemVer）是一套跨语言的语义化版本号标准。下图所示为语义化版本号示例：<br><img src="/assets/20230818/%E8%AF%AD%E4%B9%89%E5%8C%96%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6.png" alt="语义化版本控制"></p><ul><li><a href="https://semver.org/lang/zh-CN/#spec-item-8">1 为主版本号（Major）。通常只有在重构、API 不向下兼容时才会进行升级。当 Major 值为 0 时，一般认为产品处于开发或测试阶段。(必须)</a></li><li><a href="https://semver.org/lang/zh-CN/#spec-item-7">2 为次版本号（Minor）。通常在增加向下兼容新特性时升级此版本。(必须)</a></li><li><a href="https://semver.org/lang/zh-CN/#spec-item-6">3 为修订号（Patch）。通常在发布向下兼容的问题修复时更新。(必须)</a></li><li><a href="https://semver.org/lang/zh-CN/#spec-item-9">-alpha.1 为先行版本号。先行版的优先级低于相关联的标准版本。被标上先行版本号则表示这个版本并非稳定而且可能无法满足预期的兼容性需求。(非必须)</a></li><li><a href="https://semver.org/lang/zh-CN/#spec-item-10">+001 为版本编译信息。当判断版本的优先级时，版本编译信息可被忽略。因此当两个版本只有在版本编译信息有差别时，属于相同的优先层级。(非必须)</a></li></ul><h1>二、必须遵守的约定</h1><ul><li><a href="https://semver.org/lang/zh-CN/#spec-item-2">标准的版本号必采用 X.Y.Z 的格式，其中 X、Y 和 Z 为非负的整数，且禁止在数字前方补零。X 是主版本号、Y 是次版本号、而 Z 为修订号。每个元素必须以数值来递增。例如：1.9.1 -&gt; 1.10.0 -&gt; 1.11.0。</a></li><li><a href="https://semver.org/lang/zh-CN/#spec-item-3">标记版本号的软件发行后，禁止改变该版本软件的内容。任何修改都必须以新版本发行。</a></li><li><a href="https://semver.org/lang/zh-CN/#spec-item-4">主版本号为零（0.y.z）的软件处于开发初始阶段，一切都可能随时被改变。不应该被视为稳定版。</a></li><li><a href="https://semver.org/lang/zh-CN/#spec-item-5">1.0.0 的版本号用于界定首个正式版的形成。这一版本之后所有的版本号更新都基于该版本及其修改内容。</a></li><li>当 Major 或 Minor 增加 1 时，需要把后面的 Patch 清零。且注意版本号不是逢 10 进 1 的。</li></ul><h1>三、常见先行版本号标识</h1><p>先行版本号是当产品要发布大版本或者核心功能时，但是不能保证这个版本的功能 100%正常可用，这个时候就需要发布先行版本。</p><table><thead><tr><th style="text-align:left">标识</th><th style="text-align:left">说明</th><th style="text-align:left">示例</th></tr></thead><tbody><tr><td style="text-align:left">base</td><td style="text-align:left">基础版本。该版本只有开发该项目的基础架构，不涉及任务具体业务功能的实现。</td><td style="text-align:left">1.0.0-base</td></tr><tr><td style="text-align:left">snapshot</td><td style="text-align:left">快照版本是处于开发和演进中的版本，通常用于开发人员在构建和测试过程中进行频繁的版本迭代（功能不稳定）。主要面向开发人员，不适合发布到生产环境中。</td><td style="text-align:left">1.0.0-snapshot</td></tr><tr><td style="text-align:left">alpha(α)</td><td style="text-align:left">α 是希腊字母的第一个，表示最早的版本，一般此类版本包含很多 BUG ，功能也不全，主要面向的是开发人员和测试人员。</td><td style="text-align:left">1.0.0-alpha</td></tr><tr><td style="text-align:left">beta(β)</td><td style="text-align:left">公开测试版（也叫 B 测版）。 β 是希腊字母的第二个，因此这个版本比 alpha 版发布较晚一些，主要是给参与内部体验的用户测试用，该版本仍然存在很多 BUG ，但是相对 alpha 版要稳定一些。此时，基本功能已经固定，但仍然可能增加新功能。</td><td style="text-align:left">1.0.0-beta</td></tr><tr><td style="text-align:left">RC(Release Candidate)</td><td style="text-align:left">RC （候选版本），该版本功能不再增加，和最终发布版功能一样。作用是提前预览即将发行版本的内容。</td><td style="text-align:left">1.0.0-RC</td></tr><tr><td style="text-align:left">release</td><td style="text-align:left">稳定版（也叫 stable、GA 版）。在开源软件中，都有正式版，这个就是开源软件的最终发行版。</td><td style="text-align:left">1.0.0-release</td></tr></tbody></table><h1>四、部署环境的版本隔离</h1><p>我们至少需要搭建开发环境（dev）、测试环境（test）、正式环境（v）进行项目开发过程中的软件部署。而不同环境间的版本控制是隔离的，简而言之相同应用在不同环境间的版本也是会不一致的，如下图所示：</p><p><img src="/assets/20230818/%E9%83%A8%E7%BD%B2%E7%8E%AF%E5%A2%83%E7%89%88%E6%9C%AC%E9%9A%94%E7%A6%BB.png" alt="部署环境版本隔离"></p><p>从图中可看出，不同服务器环境间的版本领先程度为：dev ≥ test ≥ v</p><h1>五、各端版本管理</h1><p>在项目开发过程中，往往会出现一个服务端对应多个客户端（App、小程序、web）的情况。当各端有自己的新特性功能需要发布时，或者各端修复自身 bug 并上线时，各端正式上线发布时的版本号必然不一致。所以不同端间的版本也是互相隔离的，不同端都需要维护各自的版本。如果服务端采用微服务架构，微服务间的版本也是互相隔离的，不同的微服务间也会存在各自的版本。</p><h1>Q&amp;A</h1><ul><li><p><a href="https://semver.org/lang/zh-CN/#%E5%9C%A8-0yz-%E5%88%9D%E5%A7%8B%E5%BC%80%E5%8F%91%E9%98%B6%E6%AE%B5%E6%88%91%E8%AF%A5%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6">在 0.y.z 初始开发阶段，我该如何进行版本控制？</a><br>最简单的做法是以 0.1.0 作为你的初始化开发版本，并在后续的每次发行时递增次版本号。</p></li><li><p><a href="https://semver.org/lang/zh-CN/#%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E5%8F%91%E5%B8%83-100-%E7%89%88%E6%9C%AC%E7%9A%84%E6%97%B6%E6%9C%BA">如何判断发布 1.0.0 版本的时机？</a><br>当你的软件被用于正式环境，它应该已经达到了 1.0.0 版。如果你已经有个稳定的 API 被使用者依赖，也会是 1.0.0 版。如果你很担心向下兼容的问题，也应该算是 1.0.0 版了。</p></li><li><p><a href="https://semver.org/lang/zh-CN/#v123-%E6%98%AF%E4%B8%80%E4%B8%AA%E8%AF%AD%E4%B9%89%E5%8C%96%E7%89%88%E6%9C%AC%E5%8F%B7%E5%90%97">“v1.2.3” 是一个语义化版本号吗？</a><br>“v1.2.3” 并不是一个语义化的版本号。但是，在语义化版本号之前增加前缀 “v” 是用来表示版本号的常用做法。在版本控制系统中，将 “version” 缩写为 “v” 是很常见的。比如：git tag v1.2.3 -m “Release version 1.2.3” 中，“v1.2.3” 表示标签名称，而 “1.2.3” 是语义化版本号。</p></li><li><p>在实际项目代码中，如何验证语义化版本号的有效性和比较不同版本号间的大小？<br>可通过对应语言的第三方工具进行处理。如：<a href="https://github.com/npm/node-semver">node-semver</a>、<a href="https://github.com/vdurmont/semver4j">semver4j</a></p></li></ul><p>参考链接：<a href="https://semver.org/lang/zh-CN/">语义化版本 2.0.0</a>、<a href="https://www.jianshu.com/p/866e3996be86">浅谈软件版本号规范与项目管理</a></p>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 版本管理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nginx容器创建</title>
      <link href="/yiyuanqian_blog/2023/05/15/nginx%E5%AE%B9%E5%99%A8%E5%88%9B%E5%BB%BA/"/>
      <url>/yiyuanqian_blog/2023/05/15/nginx%E5%AE%B9%E5%99%A8%E5%88%9B%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<p>通过 shell 脚本，对 docker 环境下的 nginx 容器进行创建及运行。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">程序执行出错后终止后续命令执行</span></span><br><span class="line">set -e || echo &quot;脚本出错，终止执行！&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">判断前一条命令是否正常执行并输出提示</span></span><br><span class="line">function checkAndEcho()&#123;</span><br><span class="line"> if [ $? -ne 0 ];</span><br><span class="line"> then</span><br><span class="line">echo $1</span><br><span class="line">exit</span><br><span class="line"> else</span><br><span class="line">echo $2</span><br><span class="line"> fi</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">检查docker是否已安装</span></span><br><span class="line">echo &quot;检查docker是否已安装......&quot;</span><br><span class="line">docker -v</span><br><span class="line">checkAndEcho &quot;docker未安装！&quot; &quot;docker已安装！&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">检查nginx:latest镜像是否存在</span></span><br><span class="line">echo &quot;检查nginx:latest镜像是否存在......&quot;</span><br><span class="line">if [[ &quot;$(docker images -q nginx:latest 2&gt; /dev/null)&quot; != &quot;&quot; ]];</span><br><span class="line">then</span><br><span class="line">echo &quot;已发现nginx:latest镜像！&quot;</span><br><span class="line"> else</span><br><span class="line">echo &quot;正下载官方nginx:latest镜像中......&quot;</span><br><span class="line">docker pull nginx:latest</span><br><span class="line">fi</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">从容器复制nginx相关目录文件并授权</span></span><br><span class="line">echo &quot;创建本地pro-nginx相关文件目录中......&quot;</span><br><span class="line">docker create --name pro-nginx nginx:latest</span><br><span class="line">docker container cp pro-nginx:/etc/nginx/. /home/pro-nginx</span><br><span class="line">docker container cp pro-nginx:/var/log/nginx/. /home/pro-nginx/logs/</span><br><span class="line">docker container cp pro-nginx:/usr/share/nginx/html/. /home/pro-nginx/html/</span><br><span class="line">docker rm -f pro-nginx</span><br><span class="line">chmod -R 777 /home/pro-nginx</span><br><span class="line">echo &quot;本地pro-nginx相关文件目录创建并授权成功！&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建并运行nginx容器</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-v 挂载文件目录</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">--name 定义容器名称</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">--restart=always docker启动时容器总是自动启动</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-d 后台运行容器</span></span><br><span class="line">docker run --name pro-nginx -p 8080:8080 -p 80:80 \</span><br><span class="line">-v /home/pro-nginx/nginx.conf:/etc/nginx/nginx.conf \</span><br><span class="line">-v /home/pro-nginx/mime.types:/etc/nginx/mime.types \</span><br><span class="line">-v /home/pro-nginx/logs:/var/log/nginx \</span><br><span class="line">-v /home/pro-nginx/html:/usr/share/nginx/html \</span><br><span class="line">-v /home/pro-nginx/conf.d:/etc/nginx/conf.d \</span><br><span class="line">-v /etc/localtime:/etc/localtime \</span><br><span class="line">--name pro-nginx \</span><br><span class="line">--restart=always \</span><br><span class="line">-d nginx:latest</span><br><span class="line">checkAndEcho &quot;pro-nginx容器创建失败！&quot; &quot;pro-nginx容器运行成功！&quot;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 服务器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据可视化大屏自适应实现</title>
      <link href="/yiyuanqian_blog/2023/01/06/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96%E5%A4%A7%E5%B1%8F%E8%87%AA%E9%80%82%E5%BA%94%E5%AE%9E%E7%8E%B0/"/>
      <url>/yiyuanqian_blog/2023/01/06/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96%E5%A4%A7%E5%B1%8F%E8%87%AA%E9%80%82%E5%BA%94%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<p>我们在实施数据可视化大屏项目的开发过程中，无可避免地会遇到不同屏幕分辨率下大屏页面自适应显示的问题。通过对 css3 中 transform:scale()接口的使用，我们可以较为简单地解决大屏页面自适应问题。</p><p>基于 transform:scale()数据可视化大屏页面的自适应类型有以下三种：等比平铺、等比缩放、拉伸填充。</p><ul><li><h2 id="等比平铺">等比平铺</h2></li></ul><p>大屏页面宽度和屏幕宽度保持一致，高度按照实际大屏页面宽度与屏幕分辨率宽度的比例进行等比例缩放。参考代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> elName 页面内容根节点;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> pageSetting 页面样式设置（设计稿宽高定义）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> styleInfo 当前屏幕分辨率对应的实际页面样式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">import</span> $ <span class="keyword">from</span> <span class="string">&quot;jquery&quot;</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">setSubRootDivStyle0</span>(<span class="params">elName, pageSetting = &#123;&#125;</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> styleInfo = &#123;&#125;;</span><br><span class="line">    styleInfo.<span class="property">margin</span> = <span class="string">&quot;auto&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (pageSetting.<span class="property">height</span> &lt; $(elName).<span class="title function_">height</span>()) &#123;</span><br><span class="line">        styleInfo.<span class="property">top</span> = <span class="string">&quot;50%&quot;</span>;</span><br><span class="line">        styleInfo.<span class="property">transform</span> = <span class="string">&quot;translateY(-50%)&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    styleInfo.<span class="property">width</span> = pageSetting.<span class="property">width</span> + <span class="string">&quot;px&quot;</span>;</span><br><span class="line">    styleInfo.<span class="property">height</span> = pageSetting.<span class="property">height</span> + <span class="string">&quot;px&quot;</span>;</span><br><span class="line">    styleInfo.<span class="property">backgroundColor</span> = pageSetting.<span class="property">backgroundColor</span>;</span><br><span class="line">    styleInfo.<span class="property">backgroundSize</span> = <span class="string">`cover`</span>;</span><br><span class="line">    <span class="keyword">return</span> styleInfo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><h2 id="等比缩放">等比缩放</h2>大屏页面宽高按照当前屏幕分辨率宽高比例进行等比例缩放，在非设计稿定义的屏幕分辨率下会出现屏幕上下留空或左右留空的情况出现。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> elName 页面内容根节点;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> pageSetting 页面样式设置（设计稿宽高定义）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> styleInfo 当前屏幕分辨率对应的实际页面样式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">import</span> $ <span class="keyword">from</span> <span class="string">&quot;jquery&quot;</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">setSubRootDivStyle1</span>(<span class="params">elName, pageSetting = &#123;&#125;</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> styleInfo = &#123;&#125;;</span><br><span class="line">    <span class="keyword">let</span> scale;</span><br><span class="line">    <span class="keyword">let</span> docSquare = pageSetting.<span class="property">height</span> * pageSetting.<span class="property">width</span>;</span><br><span class="line">    <span class="keyword">let</span> rootSquare = $(<span class="variable language_">window</span>).<span class="title function_">height</span>() * $(<span class="variable language_">window</span>).<span class="title function_">width</span>();</span><br><span class="line">    <span class="keyword">let</span> offsetHeight = pageSetting.<span class="property">height</span> - $(<span class="variable language_">window</span>).<span class="title function_">height</span>();</span><br><span class="line">    <span class="keyword">let</span> offsetWidth = pageSetting.<span class="property">width</span> - $(<span class="variable language_">window</span>).<span class="title function_">width</span>();</span><br><span class="line">    <span class="keyword">if</span> (docSquare &gt; rootSquare) &#123;</span><br><span class="line">        <span class="keyword">if</span> (offsetHeight &gt; offsetWidth) &#123;</span><br><span class="line">            scale = $(<span class="variable language_">window</span>).<span class="title function_">height</span>() / pageSetting.<span class="property">height</span>;</span><br><span class="line">            styleInfo.<span class="property">left</span> =</span><br><span class="line">                ($(<span class="variable language_">window</span>).<span class="title function_">width</span>() - pageSetting.<span class="property">width</span> * scale) / <span class="number">2</span> + <span class="string">&quot;px&quot;</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            scale = $(<span class="variable language_">window</span>).<span class="title function_">width</span>() / pageSetting.<span class="property">width</span>;</span><br><span class="line">            styleInfo.<span class="property">top</span> =</span><br><span class="line">                ($(<span class="variable language_">window</span>).<span class="title function_">height</span>() - pageSetting.<span class="property">height</span> * scale) / <span class="number">2</span> + <span class="string">&quot;px&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        styleInfo.<span class="property">transform</span> = <span class="string">`scale(<span class="subst">$&#123;scale&#125;</span>)`</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (pageSetting.<span class="property">width</span> &gt; $(<span class="variable language_">window</span>).<span class="title function_">width</span>()) &#123;</span><br><span class="line">            scale = $(<span class="variable language_">window</span>).<span class="title function_">width</span>() / pageSetting.<span class="property">width</span>;</span><br><span class="line">            styleInfo.<span class="property">top</span> =</span><br><span class="line">                ($(<span class="variable language_">window</span>).<span class="title function_">height</span>() - pageSetting.<span class="property">height</span> * scale) / <span class="number">2</span> + <span class="string">&quot;px&quot;</span>;</span><br><span class="line">            styleInfo.<span class="property">transform</span> = <span class="string">`scale(<span class="subst">$&#123;scale&#125;</span>)`</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pageSetting.<span class="property">height</span> &gt; $(<span class="variable language_">window</span>).<span class="title function_">height</span>()) &#123;</span><br><span class="line">            scale = $(<span class="variable language_">window</span>).<span class="title function_">height</span>() / pageSetting.<span class="property">height</span>;</span><br><span class="line">            styleInfo.<span class="property">left</span> =</span><br><span class="line">                ($(<span class="variable language_">window</span>).<span class="title function_">width</span>() - pageSetting.<span class="property">width</span> * scale) / <span class="number">2</span> + <span class="string">&quot;px&quot;</span>;</span><br><span class="line">            styleInfo.<span class="property">transform</span> = <span class="string">`scale(<span class="subst">$&#123;scale&#125;</span>)`</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (offsetHeight &gt; offsetWidth) &#123;</span><br><span class="line">                scale = $(<span class="variable language_">window</span>).<span class="title function_">height</span>() / pageSetting.<span class="property">height</span>;</span><br><span class="line">                styleInfo.<span class="property">left</span> =</span><br><span class="line">                    ($(<span class="variable language_">window</span>).<span class="title function_">width</span>() - pageSetting.<span class="property">width</span> * scale) / <span class="number">2</span> + <span class="string">&quot;px&quot;</span>;</span><br><span class="line">                styleInfo.<span class="property">transform</span> = <span class="string">`scale(<span class="subst">$&#123;scale&#125;</span>)`</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                scale = $(<span class="variable language_">window</span>).<span class="title function_">width</span>() / pageSetting.<span class="property">width</span>;</span><br><span class="line">                styleInfo.<span class="property">top</span> =</span><br><span class="line">                    ($(<span class="variable language_">window</span>).<span class="title function_">height</span>() - pageSetting.<span class="property">height</span> * scale) / <span class="number">2</span> +</span><br><span class="line">                    <span class="string">&quot;px&quot;</span>;</span><br><span class="line">                styleInfo.<span class="property">transform</span> = <span class="string">`scale(<span class="subst">$&#123;scale&#125;</span>)`</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    $(elName).<span class="title function_">css</span>(<span class="string">&quot;overflow&quot;</span>, <span class="string">&quot;hidden&quot;</span>);</span><br><span class="line">    styleInfo.<span class="property">width</span> = pageSetting.<span class="property">width</span> + <span class="string">&quot;px&quot;</span>;</span><br><span class="line">    styleInfo.<span class="property">height</span> = pageSetting.<span class="property">height</span> + <span class="string">&quot;px&quot;</span>;</span><br><span class="line">    styleInfo.<span class="property">backgroundColor</span> = pageSetting.<span class="property">backgroundColor</span>;</span><br><span class="line">    styleInfo.<span class="property">backgroundSize</span> = <span class="string">`cover`</span>;</span><br><span class="line">    <span class="keyword">return</span> styleInfo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><h2 id="拉伸平铺">拉伸平铺</h2>大屏页面按照当前屏幕分辨率宽高进行拉伸平铺，在非设计稿定义的屏幕分辨率下大屏页面会出现拉伸变形的情况。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> elName 页面内容根节点;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> pageSetting 页面样式设置（设计稿宽高定义）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> styleInfo 当前屏幕分辨率对应的实际页面样式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">import</span> $ <span class="keyword">from</span> <span class="string">&quot;jquery&quot;</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">setSubRootDivStyle2</span>(<span class="params">elName, pageSetting = &#123;&#125;</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> styleInfo = &#123;&#125;;</span><br><span class="line">    <span class="keyword">let</span> scaleY = $(<span class="variable language_">window</span>).<span class="title function_">height</span>() / pageSetting.<span class="property">height</span>;</span><br><span class="line">    <span class="keyword">let</span> scaleX = $(<span class="variable language_">window</span>).<span class="title function_">width</span>() / pageSetting.<span class="property">width</span>;</span><br><span class="line">    styleInfo.<span class="property">transform</span> = <span class="string">`scale(<span class="subst">$&#123;scaleX&#125;</span>,<span class="subst">$&#123;scaleY&#125;</span>)`</span>;</span><br><span class="line">    $(elName).<span class="title function_">css</span>(<span class="string">&quot;overflow&quot;</span>, <span class="string">&quot;hidden&quot;</span>);</span><br><span class="line">    styleInfo.<span class="property">width</span> = pageSetting.<span class="property">width</span> + <span class="string">&quot;px&quot;</span>;</span><br><span class="line">    styleInfo.<span class="property">height</span> = pageSetting.<span class="property">height</span> + <span class="string">&quot;px&quot;</span>;</span><br><span class="line">    styleInfo.<span class="property">backgroundColor</span> = pageSetting.<span class="property">backgroundColor</span>;</span><br><span class="line">    styleInfo.<span class="property">backgroundSize</span> = <span class="string">`cover`</span>;</span><br><span class="line">    <span class="keyword">return</span> styleInfo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据可视化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android内存分析—Memory Profiler</title>
      <link href="/yiyuanqian_blog/2022/03/28/Android%E5%86%85%E5%AD%98%E5%88%86%E6%9E%90%E2%80%94Memory%20Profiler/"/>
      <url>/yiyuanqian_blog/2022/03/28/Android%E5%86%85%E5%AD%98%E5%88%86%E6%9E%90%E2%80%94Memory%20Profiler/</url>
      
        <content type="html"><![CDATA[<h1>一、内存优化概念</h1><p>内存优化一直是一个很重要但却缺乏关注的点，内存作为程序运行最重要的资源之一，需要运行过程中做到合理的资源分配与回收，不合理的内存占用轻则使得用户应用程序运行卡顿、ANR、黑屏，重则导致用户应用程序发生 OOM（out of memory）崩溃。在你认真跟踪下来可能会发现内存出现问题的地方仅仅只是一个表现的地方，并非深层次的原因，因为内存问题相对比较复杂，它是一个逐渐挤压的过程，正好在你出现问题的代码那里爆了，所以针对应用的内存问题开发者必须多加关注。</p><h1>二、Memory Profiler</h1><h2 id="2-1-简介">2.1 简介</h2><p>Memory Profiler 是 Android Studio Profiler 中的一个组件，可以帮助我们识别因内存泄漏和内存抖动导致的卡顿，无响应，甚至 crashes。它显示了应用程序内存使用的实时图形，可以捕获信息，强制 GC 以及跟踪内存分配。</p><h2 id="2-2-官方使用文档">2.2 <a href="https://developer.android.google.cn/studio/profile/memory-profiler">官方使用文档</a></h2><h2 id="2-3-内存占用类别">2.3 内存占用类别</h2><p><img src="/assets/20220328/%E5%86%85%E5%AD%98%E5%8D%A0%E7%94%A8%E7%B1%BB%E5%88%AB.png" alt="内存占用类别"></p><ul><li>Java：从 Java 或 Kotlin 代码分配的对象内存。</li><li>Native：从 C 或 C++ 代码分配的对象内存。即使应用中不使用 C++，也可能会看到此处使用的一些原生内存，如处理图像资源和其他图形时，即使编写的代码采用 Java 或 Kotlin 语言，Android 框架也会使用原生内存处理各种任务。</li><li>Graphics：图形缓冲区队列向屏幕显示像素（包括 GL 表面、GL 纹理等等）所使用的内存。需要注意这是与 CPU 共享的内存，不是 GPU 专用内存。</li><li>Stack：应用中的原生堆栈和 Java 堆栈使用的内存。通常与应用运行多少线程有关。</li><li>Code：应用用于处理代码和资源（如 dex 字节码、已优化或已编译的 dex 码、.so 库和字体）的内存。</li><li>Other：应用使用的系统不确定如何分类的内存。</li><li>Allocated：应用分配的 Java/Kotlin 对象数。它没有计入 C 或 C++ 中分配的对象。</li></ul><h2 id="2-4-内存分析重要指标">2.4 内存分析重要指标</h2><p><img src="/assets/20220328/%E5%86%85%E5%AD%98%E5%88%86%E6%9E%90%E6%8C%87%E6%A0%87.png" alt="内存分析指标"></p><ul><li><p>Depth：从 GC Root 到达这个实例的最短路径，图中的这些数字就是每个对象的深度。<br>一个对象离 GC Root 越近，它就越有可能与 GC Root 有多条路径相连，也就越可能在垃圾回收中被保存下来。以红色节点为例，如果从其左边来的任何一个引用被破坏，红色节点就会变成不可访问的状态并且被垃圾回收回收掉。而对于右边的蓝色节点来说，如果您希望它被垃圾回收，那您需要把左右两边的路径都破坏才行。值得警惕的是，如果您看到某个实例的 “Depth” 为 1 的话，这意味着它直接被 GC root 引用，同时也意味着它永远不会被自动回收。下图所示：<br><img src="/assets/20220328/depth.png" alt="depth"></p></li><li><p>Native Size：类对象所引用的 Native 对象 (蓝色节点) 所消耗的内存大小。下图所示：<br><img src="/assets/20220328/nativeSize.png" alt="nativeSize"></p></li><li><p>Shallow Size：是指对象本身消耗的内存大小，即下图所示为红色节点自身所占内存。<br><img src="/assets/20220328/shallowSize.png" alt="shallowSize"></p></li><li><p>Retained Size：下图中所有橙色节点的大小，由于一旦删除红色节点，其余的橙色节点都将无法被访问，这时候它们就会被 GC 回收掉。从这个角度上讲，它们是被红色节点所持有的，因此被命名为 “Retained Size”。<br><img src="/assets/20220328/retainedSize.png" alt="retainedSize"></p></li></ul><h1>三、内存问题表现形式</h1><h2 id="2-1-内存抖动">2.1 内存抖动</h2><p>运行的程序在 Memory Profiler 会呈现为在短时间内内存上下波动频繁触发 GC 回收。体现为 Memory Profiler 呈现锯齿状、GC 频繁导致卡顿，如下图所示：<br><img src="/assets/20220328/%E5%86%85%E5%AD%98%E6%8A%96%E5%8A%A8.webp" alt="内存抖动"></p><h2 id="2-2-内存泄露">2.2 内存泄露</h2><p>内存泄露的表现是会出现内存抖动，因为出现内存泄露时可用内存不断减少，系统需要内存时获取内存不足就会 GC，所以产生内存抖动。下图所示 ，出现内存泄露时 Memory Profiler 会呈现一个类似阶梯型的内存上升趋势，而且内存没有降下来。<br><img src="/assets/20220328/%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F.webp" alt="内存泄漏"></p><h2 id="2-3-内存溢出">2.3 内存溢出</h2><p>内存泄漏会导致内存溢出，体现为 app 卡顿，甚至程序崩溃。Android 设备出厂以后，java 虚拟机对单个应用的最大内存分配就确定下来了，超出这个值就会 OOM。单个应用可用的最大内存对应于 /system/build.prop 文件中的 dalvik.vm.heapgrowthlimit。除了因内存泄漏累积到一定程度导致 OOM 的情况以外，也有一次性申请很多内存，比如说 一次创建大的数组或者是载入大的文件如图片的时候会导致 OOM。而且，实际情况下 很多 OOM 就是因图片处理不当 而产生的。</p><p>参考链接： <a href="https://juejin.cn/post/7123452813656457253?searchId=2024011716271465FA84563498BB2AF66F#heading-7">Android 内存优化分析总结，这一篇就够了！</a>、<a href="https://www.jianshu.com/p/ab8dd0bb0941?utm_campaign=maleskine&amp;utm_content=note&amp;utm_medium=seo_notes">Android 内存优化工具：Memory Profiler</a></p>]]></content>
      
      
      <categories>
          
          <category> 安卓 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ADB Interface安装与作用</title>
      <link href="/yiyuanqian_blog/2022/02/24/adbInterface%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%9C%E7%94%A8/"/>
      <url>/yiyuanqian_blog/2022/02/24/adbInterface%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%9C%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>ADB Interface是一个安卓设备连接PC（windows系统）时所需要的驱动程序。</p><p>使用安卓设备连接PC（windows系统）时，PC会自动进行驱动程序安装。但驱动安装过程中，可能会出现下图所示情况。由于驱动程序未能正常安装，导致安卓设备不能正常与PC进行通讯，所以我们需要手动对该驱动进行安装。<br><img src="/assets/20220224/1-1.png" alt="图1-1"></p><p>我们可以通过以下步骤进行驱动的手动安装：</p><ul><li><p>打开“计算机管理”，如图1-2所示，我们可以看到ADB Interface并未正常安装运行。<br><img src="/assets/20220224/1-2.png" alt="图1-2"></p></li><li><p>点击该驱动并右键选择“更新驱动程序软件”，如图1-3所示选择“浏览计算机以查找驱动程序软件”。<br><img src="/assets/20220224/1-3.png" alt="图1-3"></p></li><li><p>如图1-4所示点击选择。<br><img src="/assets/20220224/1-4.png" alt="图1-4"></p></li><li><p>如图1-5所示点击“下一步”。<br><img src="/assets/20220224/1-5.png" alt="图1-5"></p></li><li><p>如图1-6所示点击“从磁盘安装”。<br><img src="/assets/20220224/1-6.png" alt="图1-6"></p></li><li><p>如图1-7所示点击浏览按钮，获取ADB Interface安装文件的位置后点击“确定”。ADB Interface的获取方式有两种：1、网上获取；2、如果本地有安卓SDK，可以在SDK中获取，获取路径以你实际SDK文件夹路径为准，此处为D:\Android\Sdk\extras\google\usb_driver\下的android_winusb.inf。<br><img src="/assets/20220224/1-7.png" alt="图1-7"></p></li><li><p>如图1-8所示选择并点击“下一步”，可能会出现“更新驱动程序警告”弹窗提示，点击“是”继续安装执行，即可安装完成。<br><img src="/assets/20220224/1-8.png" alt="图1-8"></p></li><li><p>ADB Interface安装好后，连接安卓设备的过程中，可能还会出现识别不出设备的情况。可以如图1-9所示打开“计算机管理”判断驱动是否已启用，如未启用则右键选择“启用”。<br><img src="/assets/20220224/1-9.png" alt="图1-9"></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 安卓 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>大数据时代：生活、工作与思维的大变革</title>
      <link href="/yiyuanqian_blog/2022/01/14/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%97%B6%E4%BB%A3%EF%BC%9A%E7%94%9F%E6%B4%BB%E3%80%81%E5%B7%A5%E4%BD%9C%E4%B8%8E%E6%80%9D%E7%BB%B4%E7%9A%84%E5%A4%A7%E5%8F%98%E9%9D%A9/"/>
      <url>/yiyuanqian_blog/2022/01/14/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%97%B6%E4%BB%A3%EF%BC%9A%E7%94%9F%E6%B4%BB%E3%80%81%E5%B7%A5%E4%BD%9C%E4%B8%8E%E6%80%9D%E7%BB%B4%E7%9A%84%E5%A4%A7%E5%8F%98%E9%9D%A9/</url>
      
        <content type="html"><![CDATA[<h3 id="当今社会因为大数据的出现，而具备了一种新型能力">当今社会因为大数据的出现，而具备了一种新型能力</h3><p>以一种前所未有的方式，通过对海量数据进行分析，获得有巨大价值的产品和服务，或深刻的洞见。</p><h3 id="大数据的起源及概念">大数据的起源及概念</h3><p>信息总量的变化还导致了信息形态的变化——量变引起了质变。最先经历信息爆炸的学科，如天文学和基因学，创造出了“大数据”这个概念。最初，这个概念是指需要处理的信息量过大，已经超出了一般电脑在处理数据时所能使用的内存量，因此工程师们必须改进处理数据的工具。这导致了新的处理技术的诞生，例如谷歌的 MapReduce 和开源 Hadoop 平台(最初源于雅虎)。这些技术使得人们可以处理的数据量大大增加。大数据是人们获得新的认知，创造新的价值地源泉；大数据还是改变市场、组织机构，以及政府与公民关系的方法。</p><h3 id="预测是大数据的核心">预测是大数据的核心</h3><p>大数据是把数学算法运用到海量的数据上来预测事情发生的可能性。预测系统之所以能够成功，关键在于它们是建立在海量数据的基础之上的。随着系统接收到的数据越来越多，通过记录找到的最好的预测与模式，可以对系统进行改造。</p><h3 id="大数据时代在分析信息时的三大转变">大数据时代在分析信息时的三大转变</h3><ul><li>可以分析更多的数据，不再依赖于随机采样。</li><li>不再热衷于追求精确度。</li><li>不再热衷于寻找因果关系。</li></ul><h3 id="数据化的概念及作用">数据化的概念及作用</h3><p>数据化意味着我们把一切都透明化，甚至包括很多我们以前认知和“信息”根本搭不上边的事情。（我认为数据化是预测的前提，能快速有效地帮助我们挖掘数据的潜在价值。）</p><p>摘录自：《大数据时代：生活、工作与思维的大变革》</p>]]></content>
      
      
      <categories>
          
          <category> 读书 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大数据 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>uni-app框架使用指南</title>
      <link href="/yiyuanqian_blog/2021/12/01/uni-app%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/"/>
      <url>/yiyuanqian_blog/2021/12/01/uni-app%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1>简述</h1><p><a href="https://uniapp.dcloud.io/">uni-app</a> 是一个基于 <a href="https://cn.vuejs.org/">Vue</a> 的前端开发框架。同时它整合了 H5+、各大主流厂商小程序、Weex 等规范及特性，致力于用户通过最低成本(一套代码)开发出兼容 Web、IOS、Android 以及各种小程序的跨平台前端应用。<br>从 <a href="https://www.dcloud.io/">DCloud</a> 官网我们可以了解到，官方不只提供了 uni-app 这个框架，还提供了详尽的开发文档、<a href="https://www.dcloud.io/hbuilderx.html">配套 IDE</a>、组件库、各种 SaaS 化服务等一整套完整的跨平台应用开发解决方案。</p><p>为了充分发挥社区的力量，官方还提供了<a href="https://ext.dcloud.net.cn/">插件市场</a>及<a href="https://ask.dcloud.net.cn/explore/">社区论坛</a>。用户可以在插件市场通过付费或免费的方式搜索获得开发过程中所需的各种插件，同样，我们也可以将自己开发的插件有偿或无偿地发布到插件市场供他人使用。我们可以在社区论坛中发布各种技术问题进行求助，也可以进行技术分享。当然，我们也可以通过付费的方式求助官方解决开发过程中遇到的问题。</p><p>uni-app 官方文档在使用教程、常见开发问题解答等方面已经有十分详尽的叙述。下面将结合自己的理解对文档中的一些要点做出汇总。</p><h1>学习要点</h1><p>在刚开始接触 uni-app 官方文档教程时，可能会因为“丰富”的文档内容和大量的技术点，一时不知道从何学起。以下是我在使用和学习 uni-app 框架过程要总结出来的一些学习要点，希望能帮助大家高效学习 uni-app 框架。当然，官方也提供了丰富的<a href="https://uniapp.dcloud.net.cn/resource">视频教程</a>帮助大家更全面更高效地学习 uni-app 框架。</p><p>由于 uni-app 框架是基于 Vue 且遵循其 SFC 开发规范，所以我们在使用 uni-app 框架进行开发前必须要先对 Vue 进行学习。在熟悉 Vue 后，我们就可以高效地进行 uni-app 框架的学习及开发了。建议对<a href="https://developers.weixin.qq.com/miniprogram/dev/framework/">微信小程序</a>开发也有所了解。因为在学习 uni-app 框架的过程中，我们会发现文档中的很多概念内容都是和微信小程序开发相同或类似的。</p><h2 id="开发环境">开发环境</h2><p>在开发 uni-app 时，我们必须要使用配套 IDE——<a href="https://www.dcloud.io/hbuilderx.html">HBuilderX</a>。官方对该 IDE 的发版还是挺频繁的，建议尽量使用最新稳定版。通过该 IDE 我们可以对 uni-app 进行多端调试及发行，具体使用教程可查看<a href="https://uniapp.dcloud.io/quickstart-hx">这里</a>。</p><h2 id="插件和组件">插件和组件</h2><p>现代前端开发遵循模块化、组件化的开发方式。为了实现 uni-app 的跨平台及提高应用性能，官方定义了多种类别的组件、插件及开发规范。了解清楚它们的作用、适用场景是高效开发 uni-app 的关键点之一。</p><ul><li><h3 id="插件分类">插件分类</h3><p>在这里，插件是指通过 uni-app 规范对 js 接口、自定义组件、页面等功能或服务的封装。它无法独立运行，必须要嵌入到 uni-app 中使用。通过封装插件，可以提供功能或服务给第三方使用。插件市场中包含了前端组件、JS SDK、原生 SDK 等插件。</p><p>在 uni-app 文档中主要包含了<a href="https://uniapp.dcloud.io/component/">前端组件</a>、<a href="https://nativesupport.dcloud.net.cn/NativePlugin/README">App 原生插件</a>、<a href="https://uniapp.dcloud.io/collocation/miniprogram-plugin">小程序插件</a>三种插件的开发说明，下面对它们进行简单总结：</p><table><thead><tr><th>插件类型</th><th>适用平台</th><th>备注</th></tr></thead><tbody><tr><td>前端组件</td><td>web、小程序、App</td><td>可以理解成视图层相关的插件，基本都是多端兼容的。</td></tr><tr><td>App 原生插件</td><td>App</td><td>使用 App 离线 SDK 开发原生插件来扩展原生能力，基于 <a href="http://doc.weex.io/zh/guide/introduction.html">Weex</a>。</td></tr><tr><td>小程序插件</td><td>对应厂商的小程序</td><td>通过 uni-app 框架可以<a href="https://uniapp.dcloud.io/collocation/miniprogram-plugin">开发</a>或<a href="https://uniapp.dcloud.io/component/mp-weixin-plugin">使用</a>不同小程序厂商的小程序插件</td></tr></tbody></table></li><li><h3 id="组件分类">组件分类</h3><p>在这里，组件主要是指通过 uni-app 规范定义的一系列视图层组件(前端组件)。这些组件基本都是多端兼容的，具体使用及限制以官方文档为准。以下 uni-app 中的组件类型做出简单总结：</p><table><thead><tr><th>类型</th><th>适用平台</th><th>所用规范</th><th>备注</th></tr></thead><tbody><tr><td>基础组件</td><td>App、小程序、web</td><td>-</td><td>可直接使用的内置组件，基本等同于微信小程序中的组件。</td></tr><tr><td><a href="https://uniapp.dcloud.io/component/uniui/uni-ui">扩展组件</a></td><td>App、小程序、web</td><td>-</td><td>除基础组件外的组件</td></tr><tr><td><a href="https://uniapp.dcloud.net.cn/frame?id=%e5%b0%8f%e7%a8%8b%e5%ba%8f%e8%87%aa%e5%ae%9a%e4%b9%89%e7%bb%84%e4%bb%b6%e6%94%af%e6%8c%81">小程序组件</a></td><td>web、App、对应厂商小程序</td><td>对应厂商小程序规范</td><td>微信小程序组件是多端兼容的、其他小程序组件只兼容自身小程序</td></tr><tr><td><a href="https://uniapp.dcloud.net.cn/nvue-outline">nvue 组件</a></td><td>App、小程序、web</td><td>nvue 组件规范</td><td>使 vue 组件具备原生渲染能力,App 端基于 Weex 的高性能渲染器进行渲染</td></tr><tr><td><a href="https://uniapp.dcloud.net.cn/component/native-component">原生组件</a></td><td>App、小程序、web</td><td>vue 组件规范或 nvue 组件规范</td><td>又分为内置原生组件和 App 端的原生组件，开发时需要注意层级覆盖问题</td></tr><tr><td><a href="https://uniapp.dcloud.io/uniCloud/unicloud-db">uniCloud 组件</a></td><td>App、小程序、web</td><td>vue 组件规范、uniCloud 组件规范</td><td>配合 uniCloud 服务的组件</td></tr><tr><td><a href="https://uniapp.dcloud.io/component/datacom?id=%e4%bb%80%e4%b9%88%e6%98%afdatacom">datacom 组件</a></td><td>App、小程序、web</td><td>vue 组件规范、datacom 组件规范</td><td>对所绑定的数据格式进行规范的组件</td></tr></tbody></table></li></ul><p>vue 页面主体在小程序端和 App 端是用 webview 渲染的，但是部分 ui 元素比如导航栏、tabbar、video、map 等是使用原生控件渲染的，所以这种方式称为混合渲染。混合渲染会存在层级覆盖的问题，具体问题描述及解决方案可查看<a href="https://uniapp.dcloud.net.cn/component/native-component">这里</a>。</p><p>插件分类所说的 App 原生插件其实分为原生组件 component 和原生模块 module，都是基于 Weex 规范。App 端原生组件只能在 nvue 页面中使用。</p><p>nvue 组件和 vue 组件不能相互引用，在 nvue 页面中只能使用 nvue 组件和 App 端原生组件。nvue 页面要不完全用 webview 渲染，要不完全用原生渲染，所以不存在层级覆盖问题。由于使用 nvue 技术时有较大的开发限制，所以不建议在开发非 App 应用时使用 nvue。适用在 App 端某些 vue 页面表现不佳的场景下使用 nvue 作为强化补充，如：App 端首页快速渲染、深度使用原生组件的页面、高性能的区域长列表或瀑布流滚动等。</p><h2 id="技术规范">技术规范</h2><p>由于 uni-app 框架是基于 Vue、Weex、微信小程序等技术的，所以框架中也用到了这些技术的开发规范。对技术规范进行整合，统一 js API 的同时，为了提高开发者效率和应用性能，官方也自定义了一些开发规范。<br>虽然 uni-app 框架是基于上述技术，但是不代表官方对上述技术做出 100%的实现，所以在原技术的实现或文档上会有所差异，在开发过程中要以 uni-app 官方文档为准。</p><ul><li><p><a href="https://cn.vuejs.org/">Vue</a> 技术规范——页面文件遵循 SFC 规范，框架已整合 Vue2 和 Vue3。</p></li><li><p><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/">微信小程序技术规范</a>——uni-app 基础组件、 JS API、生命周期等就是靠近微信小程序规范。</p></li><li><p><a href="http://doc.weex.io/zh/guide/introduction.html">Weex</a> 技术规范——uni-app 原生插件开发规范就是基于 Weex 技术规范。</p></li><li><p><a href="https://www.html5plus.org/doc/h5p.html">HTML5+规范</a>——uni-app App 端内置 HTML5+引擎，让 js 可以直接调用丰富的原生能力。</p></li><li><p><a href="https://uniapp.dcloud.net.cn/component/README?id=easycom%e7%bb%84%e4%bb%b6%e8%a7%84%e8%8c%83">easycom 组件规范</a>——uni-app 定义的组件开发规范，符合规范的组件具备自动注册、引用、按需打包的功能。</p></li><li><p><a href="https://uniapp.dcloud.net.cn/component/datacom?id=datacom%e7%bb%84%e4%bb%b6%e8%a7%84%e8%8c%83">datacom 组件规范</a>——uni-app 定义的组件开发规范，用于开发统一输入输出数据格式的组件。</p></li><li><p><a href="">nvue 技术规范</a>——符合规范的组件在 App 端使用 Weex 渲染器进行原生渲染，可以使 App 性能得到一定提高，是 Vue 页面在 App 端的性能强化补充技术。</p></li><li><p><a href="https://uniapp.dcloud.net.cn/component/README?id=uni_module%e8%a7%84%e8%8c%83">uni_module 规范</a>——uni-app 定义的插件开发规范，符合 uni_module 规范的插件可很方便地更新已上传到插件市场的插件。</p></li></ul><h2 id="跨端兼容">跨端兼容</h2><p>uni-app 官方尽最大限度保证了常用组件、JS API 等方面的跨平台兼容，但是每个平台都会有自己的一些特性，因此会存在无法跨平台的情况。因此 uni-app 框架通过<a href="https://uniapp.dcloud.net.cn/platform?id=%e8%b7%a8%e7%ab%af%e5%85%bc%e5%ae%b9">条件编译</a>技术，高效地解决了不同平台的个性化差异。</p><h2 id="其他">其他</h2><ul><li><a href="https://uniapp.dcloud.net.cn/use-html5plus">使用 HTML5+注意事项</a></li><li><a href="https://uniapp.dcloud.net.cn/matter">跨端开发注意事项</a></li><li><a href="https://uniapp.dcloud.net.cn/snippet">高效开发技巧</a></li><li><a href="https://uniapp.dcloud.net.cn/performance">性能优化建议</a></li><li><a href="https://uniapp.dcloud.net.cn/adapt">宽屏适配指南</a></li><li><a href="https://uniapp.dcloud.net.cn/select">选型评估指南</a></li><li><a href="https://uniapp.dcloud.net.cn/faq">常见问题解决</a></li><li><a href="https://uniapp.dcloud.net.cn/component/native-component?id=vue%e9%a1%b5%e9%9d%a2%e5%b1%82%e7%ba%a7%e8%a6%86%e7%9b%96%e8%a7%a3%e5%86%b3%e6%96%b9%e6%a1%88">vue 页面层级覆盖解决方案</a></li><li><a href="https://uniapp.dcloud.net.cn/translate">其他项目转 uni-app</a></li><li><a href="https://ask.dcloud.net.cn/article/114">Native.js 示例汇总</a></li></ul><h2 id="混合开发">混合开发</h2><ul><li><a href="https://nativesupport.dcloud.net.cn/README">uni 小程序 SDK</a></li><li><a href="https://nativesupport.dcloud.net.cn/NativePlugin/README">原生插件开发</a></li></ul><p>通过对 uni-app 框架的使用，使我对<a href="https://uniapp.dcloud.net.cn/hybrid">混合开发</a>及选型有了更清晰的了解。</p><h2 id="问题及解决方法">问题及解决方法</h2><p>在使用 uni-app 框架开发的过程中，可能会遇到各种问题，大家可以优先通过官方渠道搜索解决方案，如：<a href="https://uniapp.dcloud.net.cn/faq">常见问题解决</a>、<a href="https://github.com/dcloudio/uni-app/issues">gitHub/Issues</a>、<a href="https://ask.dcloud.net.cn/explore/">社区论坛</a>，同时值得一提的是官方文档的站内搜索挺友好的。以下是对我在开发过程中遇到的问题及解决方法的总结。</p><ol><li><p>nvue 页面和 vue 页面在应用中可以混搭、互相跳转，但是在 nvue 组件和 vue 组件不能互相混搭是引用。虽然 nvue 组件在结构和 vue 组件很相似，但实际上在很多方面是有局限性和区别的，必须要严格按照 nvue 技术规范进行开发。</p></li><li><p>在开发 uni-app 时需求可能不需要兼容 web 端，但我认为能最起码做到对 web 端视图层的样式兼容是很有必要的，有助于我们在开发过程中的调试。</p></li><li><p>通过 HbuilderX 新建 uni-app 项目时，我们可选择 vue 版本。如果原有 uni-app 项目想从 vue2.x 升级到 vue3.x，可查看<a href="https://uniapp.dcloud.net.cn/migration-to-vue3">这里</a>和<a href="https://ask.dcloud.net.cn/article/37834">这里</a>。不同 vue 版本的项目工程模板所使用的 web 端编译打包技术是不一样的。</p><table><thead><tr><th>vue 版本</th><th>打包技术</th><th>脚手架参考</th><th>备注</th></tr></thead><tbody><tr><td>2.x</td><td>webpack</td><td><a href="https://cli.vuejs.org/zh/config/#vue-config-js">vue-cli3</a></td><td><a href="https://uniapp.dcloud.net.cn/collocation/vue-config">配置说明</a>、<a href="https://cli.vuejs.org/zh/guide/mode-and-env.html#%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F">环境变量设置</a></td></tr><tr><td>3.x</td><td>rollup</td><td><a href="https://vitejs.cn/guide/">vite</a></td><td>rollup 本身是不支持 commonJS 模块化规范的，可以安装<a href="https://www.npmjs.com/package/vite-plugin-commonjs">插件</a>提供支持。<a href="https://vitejs.cn/guide/env-and-mode.html#env-variables">环境变量设置</a></td></tr></tbody></table></li><li><p>vue.config.js(vue2.x)和 vite.config.js(vue3.x) 是项目工程中的可选配置文件，但并不是所有配置项更改后都能生效，以官方说明为准。且这两个配置文件只对 web 端打包有效，如 3 中所提及的环境变量在小程序端和 App 端是不能正常使用的。</p></li><li><p>uni-app 全局变量实现可看<a href="https://ask.dcloud.net.cn/article/35021">这里</a>。</p></li><li><p>当使用 HbuilderX 开启或重启调试时，可能会出现打包失败的情况(如下图)，则可以删除生成的 unpackage 里的 dist 文件夹后再启动调试。不建议直接删除 unpackage 文件夹，因为如果正在通过自定义基座进行 App 真机调试，那么自定义基座就会被删除，需要重新制作自定义基座。<br><img src="/assets/20211201/1-1.png" alt="图1-1"></p></li><li><p>当使用自定义基座进行 App 端真机调试时，如果 manifest.json 中 App 相关的配置项发生了更改都需要重新制作自定义基座。</p></li><li><p>安卓原生插件开发时，通过 globalEvent 事件对象对原生事件进行监听，可能会出现失效的情况。通过查看源码，可通过如下方式解决。</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String,Object&gt; params=<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">params.put(<span class="string">&quot;key&quot;</span>,<span class="string">&quot;value&quot;</span>);</span><br><span class="line">mUniSDKInstance.fireModuleEvent(<span class="string">&quot;myEvent&quot;</span>, params);</span><br></pre></td></tr></table></figure></li><li><p>安卓设备连接 PC（windows 系统）进行真机调试时，可能会出现由于未正确安装 ADB Interface 导致 Hbuilder 找不到运行设备的情况，可参考<a href="https://yiyuanqian.gitee.io/2022/02/24/adbInterface%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%9C%E7%94%A8/">这里</a>进行解决。</p></li><li><p>通过 App 本地离线工程制作自定义调试基座进行真机调试，如出现 Hbuilder 控制台无法打印调试信息，需检查 App 本地离线工程中的 dcloud_control.xml 文件并确保如下配置。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;hbuilder debug=<span class="string">&quot;true&quot;</span> syncDebug=<span class="string">&quot;true&quot;</span>&gt;</span><br></pre></td></tr></table></figure></li></ol><h1>项目工程模板</h1><p>HBuilderX 创建的工程模板结构是比较简单，为了满足自身项目开发需要，我基于官方的基础模板配合 HBuilderX 插件搭建了一个(<a href="https://gitee.com/yiyuanqian/nanjing-uniapp">git 仓库地址</a>)。</p><ul><li><p>配合安装的 HBuilderX 插件：<a href="https://ext.dcloud.net.cn/plugin?name=eno-vue">Vue/Vuex/Vue Router 代码块</a>、<a href="https://ext.dcloud.net.cn/plugin?name=typescript-server">typescript 语言服务</a>、<a href="https://ext.dcloud.net.cn/plugin?name=compile-typescript">typescript 编译</a>、<a href="https://ext.dcloud.net.cn/plugin?name=validate-stylelint">stylelint</a>、<a href="https://ext.dcloud.net.cn/plugin?name=formator-prettier">prettier</a>、<a href="https://ext.dcloud.net.cn/plugin?name=eslint-vue">eslint-plugin-vue</a>、<a href="https://ext.dcloud.net.cn/plugin?name=compile-dart-sass">dart-sass 编译</a></p></li><li><p>工程模板能力：vue3、typeScript、prettier、eslint、husky、babel</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> uni-app </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nginx使用小结</title>
      <link href="/yiyuanqian_blog/2021/10/10/nginx%E4%BD%BF%E7%94%A8%E5%B0%8F%E7%BB%93/"/>
      <url>/yiyuanqian_blog/2021/10/10/nginx%E4%BD%BF%E7%94%A8%E5%B0%8F%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h2 id="简介">简介</h2><p>nginx是一款高性能、轻量级的Http和反向代理web服务器软件。</p><h2 id="实际应用">实际应用</h2><ul><li><p>正向代理：代理服务器代替客户端对目标服务器进行请求并返回请求内容，如下图所示。<br><img src="/assets/20211010/1-1.png" alt="图1-1"></p></li><li><p>反向代理：客户端请求对外暴露的代理服务器，代理服务器选择目标服务器进行请求转发；目标服务器返回请求结果给代理服务器，代理服务器转发请求结果给客户端，如下图所示。<br><img src="/assets/20211010/1-2.png" alt="图1-2"></p></li></ul><figure class="highlight nginx"><figcaption><span>反向代理配置示例</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#如果请求头中有Upgrade就直接设置到响应头中，并把Connection设置为upgrade；否则把Connection设置为close，如普通HTTP请求。</span></span><br><span class="line"><span class="attribute">map</span> <span class="variable">$http_upgrade</span> <span class="variable">$connection_upgrade</span> &#123;</span><br><span class="line">  <span class="attribute">default</span> upgrade;</span><br><span class="line">  &#x27;&#x27; close;</span><br><span class="line">&#125;</span><br><span class="line">server&#123;</span><br><span class="line">  <span class="attribute">listen</span> <span class="number">80</span>; <span class="comment">#配置监听端口</span></span><br><span class="line">  <span class="attribute">server_name</span> www.demo.com; <span class="comment">#域名设置</span></span><br><span class="line">  <span class="section">location</span> / &#123;</span><br><span class="line">     <span class="attribute">proxy_pass</span> http://xx.xx.xx:8080/; <span class="comment">#被代理的目标服务器地址</span></span><br><span class="line">     </span><br><span class="line">    <span class="comment">#websocket代理</span></span><br><span class="line">     <span class="attribute">proxy_http_version</span> <span class="number">1</span>.<span class="number">1</span>; <span class="comment">#http协议版本号(默认为1.0)，进行websocket代理时，必须要设置http协议版本号为1.1</span></span><br><span class="line">     <span class="attribute">proxy_set_header</span> Upgrade <span class="variable">$http_upgrade</span>; <span class="comment">#进行websocket代理时进行协议升级的头部信息</span></span><br><span class="line">     <span class="attribute">proxy_set_header</span> Connection <span class="string">&quot;upgrade&quot;</span>; <span class="comment">#进行websocket代理时进行协议升级的头部信息</span></span><br><span class="line"></span><br><span class="line">     <span class="comment">#记录客户端信息</span></span><br><span class="line">     <span class="attribute">proxy_set_header</span> Host <span class="variable">$host</span>; <span class="comment">#记录真实发出请求的客户端host</span></span><br><span class="line">     <span class="attribute">proxy_set_header</span> X-Real-IP <span class="variable">$remote_addr</span>; <span class="comment">#记录真实发出请求的客户端ip</span></span><br><span class="line">     <span class="attribute">proxy_set_header</span> X-Forwarded-For <span class="variable">$proxy_add_x_forwarded_for</span>; <span class="comment">#多级代理时，记录完整代理信息</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>负载均衡：负载均衡实现方式有很多种，可通过nginx反向代理功能结合自带的均衡规则实现应用层的负载均衡。nginx负载均衡规则有如下几种：<ul><li>轮询：默认方式；</li><li>weight：权重方式；</li><li>ip_hash：依据ip分配方式；</li><li>least_conn：最少连接方式；</li><li>fair：响应时间方式（第三方）；</li><li>url_hash：依据URL分配方式（第三方）。<br><img src="/assets/20211010/1-3.png" alt="图1-3"></li></ul></li></ul><figure class="highlight nginx"><figcaption><span>负载均衡配置示例</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#上游服务器组  </span></span><br><span class="line"><span class="section">upstream</span> demo_server &#123;</span><br><span class="line">  <span class="attribute">server</span> localhost:<span class="number">8080</span>;</span><br><span class="line">  <span class="attribute">server</span> localhost:<span class="number">8081</span>;</span><br><span class="line">  <span class="attribute">server</span> localhost:<span class="number">8082</span>;</span><br><span class="line">  <span class="attribute">server</span> localhost:<span class="number">8083</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">  <span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">  <span class="attribute">server_name</span> localhost;</span><br><span class="line">  <span class="section">location</span> /balance/ &#123;</span><br><span class="line">   <span class="attribute">proxy_pass</span> http://demo_server;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>动静分离：代理服务器将静态请求、动态请求分别转发到静态资源服务器、动态资源服务器并返回请求响应，从而提高服务器访问效率。<br><img src="/assets/20211010/1-4.png" alt="图1-4"></p></li><li><p>常用超时配置说明：</p></li></ul><table><thead><tr><th>超时类型</th><th>默认值</th><th>上下文</th><th>备注</th></tr></thead><tbody><tr><td>client_header_timeout</td><td>60s</td><td>http server</td><td>指定等待client发送一个请求头的超时时间（例如：GET / HTTP/1.1）</td></tr><tr><td>client_body_timeout</td><td>60s</td><td>http server location</td><td>设置请求体的读超时时间</td></tr><tr><td>keepalive_timeout</td><td>75s</td><td>http server location</td><td>指定了与client的keep-alived的连接超时时间</td></tr><tr><td>lingering_timeout</td><td>5s</td><td>http server location</td><td>在关闭连接前，会检测是否有用户发送的数据到达服务器，如果超过lingering_timeout时间后还没有数据可读，就直接关闭连接；否则，必须在读取完连接缓冲区上的数据并丢弃掉后才会关闭连接。</td></tr><tr><td>proxy_connect_timeout</td><td>60s</td><td>http server location</td><td>设置upstream server的连接超时时间</td></tr><tr><td>proxy_read_timeout</td><td>60s</td><td>http server location</td><td>该指令设置与代理服务器的读超时时间。它决定了nginx会等待多长时间来获得请求的响应。这个时间不是获得整个response的时间，而是两次reading操作的时间。</td></tr><tr><td>proxy_send_timeout</td><td>60s</td><td>http server location</td><td>这个指定设置了发送请求给upstream服务器的超时时间。超时设置不是为了整个发送期间，而是在两次write操作期间。如果超时后，upstream没有收到新的数据，nginx会关闭连接。</td></tr><tr><td>proxy_upstream_fail_timeout（fail_timeout）</td><td>10s</td><td>upstream</td><td>Upstream模块下server指令的参数，设置了某一个upstream后端失败了指定次数（max_fails）后，该后端不可操作的时间，默认为10秒。</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 服务器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>css3实现毛玻璃效果</title>
      <link href="/yiyuanqian_blog/2021/06/10/css3%E5%AE%9E%E7%8E%B0%E6%AF%9B%E7%8E%BB%E7%92%83%E6%95%88%E6%9E%9C/"/>
      <url>/yiyuanqian_blog/2021/06/10/css3%E5%AE%9E%E7%8E%B0%E6%AF%9B%E7%8E%BB%E7%92%83%E6%95%88%E6%9E%9C/</url>
      
        <content type="html"><![CDATA[<p>我们可以通过 css3 中的 filter:blur()和 backdrop-filter:blur()接口实现毛玻璃效果。</p><ul><li><h2 id="filter-blur">filter:blur()</h2></li></ul><p>filter 属性将模糊或颜色偏移等图形效果应用于元素。滤镜通常用于调整图像、背景和边框的渲染。</p><p>当我们对 id 为 demo 的节点进行 filter:blur()滤镜设置后，其设置的背景图片不受 blur 滤镜影响，且子节点的内容都会被模糊处理。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;demo&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>hello world!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="selector-id">#demo</span> &#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">width</span>: <span class="number">100vw</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">height</span>: <span class="number">100vh</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">background-image</span>: <span class="built_in">url</span>(<span class="string">&quot;demo.png&quot;</span>);</span></span><br><span class="line"><span class="language-css">        <span class="attribute">background-size</span>: cover;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">background-repeat</span>: no-repeat;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">filter</span>: <span class="built_in">blur</span>(<span class="number">50px</span>);</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><p>我们可以通过设置::before 伪元素实现背景图片毛玻璃效果，并解决上述问题。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="selector-id">#demo</span><span class="selector-pseudo">::before</span> &#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">content</span>: <span class="string">&quot;&quot;</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">position</span>: absolute;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">top</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">left</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">width</span>: <span class="number">100vw</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">height</span>: <span class="number">100vh</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">background-image</span>: <span class="built_in">url</span>(<span class="string">&quot;demo.png&quot;</span>);</span></span><br><span class="line"><span class="language-css">        <span class="attribute">background-size</span>: cover;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">background-repeat</span>: no-repeat;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">filter</span>: <span class="built_in">blur</span>(<span class="number">50px</span>);</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><p>当我们对深色图片进行毛玻璃效果设置时，会发现图片四周出现不协调的白边现象，我们可以对 demo 节点设置相同的背景图片或颜色相近的背景颜色进行处理。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="selector-id">#demo</span> &#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">background-size</span>: cover;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">background-repeat</span>: no-repeat;</span></span><br><span class="line"><span class="language-css">        <span class="comment">/* background-color:#000; */</span></span></span><br><span class="line"><span class="language-css">        <span class="attribute">background-image</span>: <span class="built_in">url</span>(<span class="string">&quot;demo.html&quot;</span>);</span></span><br><span class="line"><span class="language-css">        <span class="attribute">width</span>: <span class="number">100vw</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">height</span>: <span class="number">100vh</span>;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><h2 id="backdrop-filter-blur">backdrop-filter:blur()</h2></li></ul><p>backdrop-filter 可以让你为一个元素后面区域添加图形效果（如模糊或颜色偏移）。</p><p>当我们对 id 为 demo 的节点进行 backdrop-filter:blur()设置后，能正常实现该节点背景图片的模糊效果，并且其子节点内容能正常显示，浅色背景图片模糊时也不会出现白边现象。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;demo&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>hello world!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="selector-id">#demo</span> &#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">width</span>: <span class="number">100vw</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">height</span>: <span class="number">100vh</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">background-image</span>: <span class="built_in">url</span>(<span class="string">&quot;demo.png&quot;</span>);</span></span><br><span class="line"><span class="language-css">        <span class="attribute">background-size</span>: cover;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">background-repeat</span>: no-repeat;</span></span><br><span class="line"><span class="language-css">        backdrop-<span class="attribute">filter</span>: <span class="built_in">blur</span>(<span class="number">50px</span>);</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><p>通过 backdrop-filter 实现背景图片毛玻璃效果相比于 filter 更灵活简单，但兼容性和性能较差，所以还是推荐使用 filter。</p>]]></content>
      
      
      <categories>
          
          <category> web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> css3 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WebGL技术小结</title>
      <link href="/yiyuanqian_blog/2020/04/20/WebGL%E6%8A%80%E6%9C%AF%E5%B0%8F%E7%BB%93/"/>
      <url>/yiyuanqian_blog/2020/04/20/WebGL%E6%8A%80%E6%9C%AF%E5%B0%8F%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h2 id="GPU">GPU</h2><p>GPU（图形处理单元）是一种专门为图形处理而设计的处理器。主要作用是染图像、视频和动画，以提高视觉效果和性能。GPU主要由显示主芯片、显示缓冲存储器、RAMD/A转换器、GPC（图形处理器簇）、TPC（纹理处理簇）、SM（流处理器）、Warp（线程束）、SP（标量处理器）、Core（核心）、ALU（算术逻辑单元）、FPU（浮点运算单元）组成。</p><h2 id="图形绘制流水线">图形绘制流水线</h2><p>图形的渲染流程，则称为渲染管线，渲染管线主要包括两个功能：一是将物体3D坐标转变为屏幕空间2D坐标，二是为屏幕每个像素点进行着色，渲染管线的一般流程如下图所示。分别是：顶点处理、裁剪和图元组装、光栅化、片元处理（像素处理）、输出。<br><img src="/assets/20200420/%E5%9B%BE%E5%BD%A2%E6%B8%B2%E6%9F%93%E6%B5%81%E7%A8%8B.png" alt="图形渲染流程"><br><img src="/assets/20200420/%E5%87%A0%E4%BD%95%E9%98%B6%E6%AE%B5%E5%92%8C%E5%85%89%E6%A0%85%E5%8C%96%E9%98%B6%E6%AE%B5.png" alt="几何阶段和光栅化阶段"></p><p>几何阶段和光栅化阶段中，绿色阶段完全可编程，黄色阶段可配置不可编程，蓝色阶段完全固定。</p><h2 id="着色器">着色器</h2><p>着色器是WebGL依赖的实现图像渲染的一种绘图机制。WebGL在GPU中运行，因此需要使用能够在GPU上运行的代码（着色器程序）。</p><h2 id="OpenGL与OpenGL-ES">OpenGL与OpenGL ES</h2><p>OpenGL本身是一套规范，不是API，通过OpenGL来统一各个显卡厂家实现操作图形、图像的实现标准。OpenGL ES是OpenGL的子集，它提供了一种轻量级的、可移植的3D图形API解决方案。从2.0版本开始，OpenGL支持可编程着色器方法，这个支持可以让我们通过着色器语言编写着色器程序，代表我们可以精确控制每个像素的位置和颜色。在OpenGL2.0规范中，GPU可以执行着色器程序，根据着色器程序生成像素数据，最终显示在屏幕上。</p><p><img src="/assets/20200420/OpenGL%E4%B8%8EOpenGLES.png" alt="OpenGL与OpenGLES"></p><h2 id="WebGL">WebGL</h2><p>WebGL是一项结合了HTML5和JavaScript，用来在网页上绘制和渲染复杂三维图形的技术。WebGL通过JavaScript操作OpenGL接口的标准，把三维空间图像显示在二维的屏幕上。WebGL的技术规范继承自OpenGL ES。</p><p><img src="/assets/20200420/%E4%BC%A0%E7%BB%9F%E7%9A%84%E5%8A%A8%E6%80%81%E7%BD%91%E9%A1%B5%EF%BC%88%E5%B7%A6%EF%BC%89%E5%92%8CWebGL%E7%BD%91%E9%A1%B5%EF%BC%88%E5%8F%B3%EF%BC%89.png" alt="传统的动态网页（左）和WebGL网页（右）"></p><p>资料参考：<a href="https://juejin.cn/post/6966584226758000648?searchId=202403051351176CC951D439B7E075F882">前端也要懂图形化： 浅谈 WebGL 技术</a>、<a href="https://blog.csdn.net/Game_jqd/article/details/78868373">GPU渲染管线与可编程着色器</a>、<a href="https://juejin.cn/post/6875115400154054669?searchId=202403051351176CC951D439B7E075F882">乘风破浪的WebGL系列-初识WebGL</a></p>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 浏览器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浏览器存储方式小结</title>
      <link href="/yiyuanqian_blog/2020/03/28/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F%E5%B0%8F%E7%BB%93/"/>
      <url>/yiyuanqian_blog/2020/03/28/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F%E5%B0%8F%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>本文以新版谷歌浏览器为例，对Cookie、SessionStorage、LocalStorage、IndexedDB这4种浏览器存储方式进行小结。由于浏览器同源策略的限制，不同域下对应的存储内容无法修改和访问。</p><h2 id="存储方式概括对比">存储方式概括对比</h2><table><thead><tr><th>方式</th><th>存储大小</th><th>存储格式</th><th>生命周期</th><th>与服务器端通信</th><th>使用场景</th></tr></thead><tbody><tr><td>Cookie</td><td>4KB左右（指单个cookie保存的数据，而不是所有cookie的总大小）</td><td>键值对形式保存，仅支持字符串格式</td><td>可由服务器端或浏览器端调用webApi生成，设置过期时间进行清除</td><td>是</td><td>1、记住密码，下次自动登录。2、购物车功能。3、用户浏览数据统计。</td></tr><tr><td>SessionStorage</td><td>5MB左右（所有value的总大小）</td><td>键值对形式保存，仅支持字符串格式</td><td>主动清除或同域名下所有页面关闭就清理</td><td>否</td><td>1、保存本次会话的页面表单状态。2、保存本次会话的页面浏览记录。</td></tr><tr><td>LocalStorage</td><td>5MB左右（所有value的总大小）</td><td>键值对形式保存，仅支持字符串格式</td><td>除非主动清除否则一直存在</td><td>否</td><td>持久化保存网站中的稳定页面资源，如logo图片等。</td></tr><tr><td>IndexedDB</td><td>理论上无限制</td><td>键值对形式保存，支持多种类型数据</td><td>除非主动清除否则一直存在</td><td>否</td><td>用于浏览器端大数据量存储。</td></tr></tbody></table><h2 id="cookie">cookie</h2><ul><li><p>Cookie实际用途并非用于本地存储，而是用于“维持与服务器端的状态”（http协议是无状态的）。</p></li><li><p>Cookie不仅有存储大小限制，而且不同的浏览器对Cookie个数也有数量限制。</p></li><li><p>由于Cookie会参与服务器端通信，所以过多的Cookie会严重影响网络性能。</p></li><li><p>Cookie可由服务器端设置，或者浏览器端调用webApi进行设置。</p></li><li><p>Cookie的过期日期和时间只与客户端有关，而不是服务器端。</p></li><li><p>Cookie相关属性设置：</p><table><thead><tr><th>属性</th><th>作用</th><th>默认值</th></tr></thead><tbody><tr><td>Value</td><td>所设置Cookie的值，为了保证安全最好进行加密后设置。</td><td>空</td></tr><tr><td>Domain</td><td>指定访问该Cookie的web站点或域，并且子域名可以访问父域名Cookie。</td><td>仅当前文档的主机可访问，子域名不可以访问。</td></tr><tr><td>Expires</td><td>Cookie过期时间。</td><td>会话Cookie，关闭浏览器后失效。</td></tr><tr><td>MaxAge</td><td>Cookie有效时间，单位秒，优先于expires，当≤0时立即过期。</td><td>空</td></tr><tr><td>HttpOnly</td><td>不能通过JS访问Cookie，有效防止XSS攻击。</td><td>false</td></tr><tr><td>Secure</td><td>只能在https请求中携带，加密传输，提高安全性。</td><td>false</td></tr><tr><td>SameSite</td><td>规定浏览器不能在跨域请求中携带Cookie，防止CSRF攻击。</td><td>false</td></tr><tr><td>Path</td><td>指定web站点下可以访问该Cookie的路径，包括子路径。</td><td>/ （例：Path=/docs，则 /docs/doc1、/docs/doc1/doc1-1都可以匹配）</td></tr></tbody></table></li></ul><h2 id="WebStorage（SessionStorage、LocalStorage）">WebStorage（SessionStorage、LocalStorage）</h2><ul><li><p>LocalStorage在所有同源窗口中都是共享访问的，而SessionStorage必须要在同源状态下的相同窗口才能共享访问。</p></li><li><p>WebStorage是对Cookie的扩展，只能适用于存储少量简单的数据。</p></li><li><p>只能存储字符串类型的数据。</p></li></ul><h2 id="IndexedDB">IndexedDB</h2><ul><li>属于浏览器端的非关系型数据库，通过键值对形式保存，支持多种类型数据。</li><li>可进行大数据量及多种类型数据的存储。</li></ul><p>参考资料：<a href="https://juejin.cn/post/6844903812092674061?searchId=20240226101941FC0247D6D66D413BFB09">深入了解浏览器存储–从cookie到WebStorage、IndexedDB</a></p>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 浏览器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浏览器缓存机制</title>
      <link href="/yiyuanqian_blog/2020/02/25/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/"/>
      <url>/yiyuanqian_blog/2020/02/25/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>本文以谷歌浏览器为例，结合相关参考资料。对浏览器缓存机制进行简单总结，不对其他类型浏览器差异化对比。缓存的使用是性能优化中较为简单有效的一种优化方式。合理的缓存策略能缩短网络资源的请求路径，减少请求延迟，并且由于缓存文件的重复利用，能减少网络带宽，降低网络负载。</p><h2 id="缓存位置">缓存位置</h2><h3 id="Service-Worker"><a href="https://juejin.cn/post/6844903887296528398?searchId=20240228164813FCDD6B93D8CE6E6EE424#heading-5">Service Worker</a></h3><ul><li><code>Service Worker+Fetch+</code><a href="https://juejin.cn/post/6844903560732229645?searchId=20240229090926D4E2B8425319C8CB682C#heading-3"><code>CacheStorage</code></a>使开发者能通过编程方式自主控制对页面资源的缓存。</li><li>通过<code>Service Worker</code>拦截请求进行缓存控制的方式，无论所拦截的页面资源是否命中，浏览器都会显示是从 <code>Service Worker</code> 中获取的内容。</li><li><code>Service Worker</code>服务于同源策略下的多个页面。</li><li><code>Service Worker</code>会常驻浏览器中，即便注册它的页面已经关闭，也不会停止运行，本质就是一个浏览器后台线程。</li><li><code>Service Worker</code>可结合<a href="https://juejin.cn/post/6844903560732229645?searchId=20240229090926D4E2B8425319C8CB682C#heading-3">相关技术</a>实现 PWA 离线应用。</li></ul><h3 id="Memory-Cache">Memory Cache</h3><ul><li><p>存储在内存中的缓存，内存容量有限，主要用于存储使用率高的资源文件。</p></li><li><p>关闭页面后，内存中的缓存会被释放。</p></li></ul><h3 id="Disk-Cache">Disk Cache</h3><ul><li><p>存储在硬盘中的缓存，硬盘容量较大，会带来<code>I/O</code>开销，主要用于存储使用率低的资源文件或者体积大的资源文件。</p></li><li><p>当内存使用率高时，资源文件也会优先存储到硬盘。</p></li><li><p>关闭页面后，硬盘中的缓存还会存在。</p></li></ul><h3 id="Push-Cache">Push Cache</h3><ul><li><p>基于<code>HTTP/2</code>，国内并不普及，且不同浏览器的实现和支持程度也不一样。</p></li><li><p>所有的资源都能被推送，并且能够被缓存。</p></li><li><p>可以推送 <code>no-cache 和 no-store</code> 的资源。</p></li><li><p>连接被关闭，<code>Push Cache</code> 就被释放。</p></li><li><p>多个页面可以使用同一个 HTTP/2 的连接，也就可以使用同一个<code>Push Cache</code>。这主要还是依赖浏览器的实现而定，出于对性能的考虑，有的浏览器会对相同域名但不同的 tab 标签使用同一个 http 连接。</p></li><li><p><code>Push Cache</code>中的缓存只能被使用一次。</p></li><li><p>浏览器可以拒绝接受已经存在的资源推送。</p></li><li><p>可以给其他域名推送资源。</p></li></ul><h2 id="浏览器缓存策略">浏览器缓存策略</h2><p>通过对浏览器端请求设置请求头，服务器端响应设置响应头的方式实现浏览器端的缓存策略。浏览器缓存类型分为强缓存和协商缓存，下表是他们的对比。</p><table><thead><tr><th>缓存类型</th><th>优先级</th><th>HTTP Header</th><th>是否真实访问服务器</th><th>状态码</th><th style="text-align:left">内容来源（Size）</th></tr></thead><tbody><tr><td>强缓存</td><td>先</td><td><code>Expires和Cache-Control</code></td><td>否</td><td>200</td><td style="text-align:left"><code>from disk cache或from memory cache</code></td></tr><tr><td>协商缓存</td><td>后</td><td><code>Last-Modified和ETag</code></td><td>是</td><td>304 或 200</td><td style="text-align:left">状态码 304 时，<code>from disk cache或from memory cache</code>；状态码 200 时，显示服务器返回的实际内容大小。</td></tr></tbody></table><h2 id="浏览器缓存过程">浏览器缓存过程</h2><p><img src="/images/20200225/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98%E7%AD%96%E7%95%A5.png" alt="浏览器缓存策略"></p><p>如果没设置任何缓存策略，浏览器会采用一个启发式的算法，通常会取响应头中的 <code>Date</code> 减去 <code>Last-Modified</code> 值的 10% 作为缓存时间。</p><h2 id="浏览器缓存的实际应用">浏览器缓存的实际应用</h2><ol><li><p>频繁变动的资源：设置<code>Cache-Control:no-cache</code>禁止强缓存策略，只通过协商缓存去判断资源的有效性。虽然不能减少请求次数，但能显著减少响应数据的大小。</p></li><li><p>不频繁变动的资源：设置 <code>Cache-Control:max-age=31536000</code> 使资源有效时间尽可能大，如在线提供的类库就是通过这种方式。当资源需要更新时，则改变资源请求路径（如设置版本号）。</p></li></ol><h2 id="用户行为与浏览器缓存">用户行为与浏览器缓存</h2><ul><li>打开网页，地址栏输入地址： 查找 <code>Disk Cache</code> 中是否有匹配。如有则使用；如没有则发送网络请求。</li><li>普通刷新 (<code>F5</code>)：因为 TAB 并没有关闭，因此 <code>Memory Cache</code>是可用的，会被优先使用(如果匹配的话)。其次才是 <code>Disk Cache</code>。</li><li>强制刷新 (<code>Ctrl + F5</code>)：浏览器不使用缓存，因此发送的请求头部均带有 <code>Cache-control: no-cache</code>(为了兼容，还带了 <code>Pragma: no-cache</code>),服务器直接返回 200 和最新内容。</li></ul><p>参考资料：<a href="https://juejin.cn/post/6844903757872889870">深入浅出浏览器缓存机制</a></p>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 浏览器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浏览器基本原理</title>
      <link href="/yiyuanqian_blog/2020/01/10/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/"/>
      <url>/yiyuanqian_blog/2020/01/10/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>本文以主流的新版谷歌浏览器为例，结合相关参考资料，对浏览器原理进行简要分析。不同的类型或者版本的浏览器的实现实现都有所差异，本文不做对比讨论。</p><h2 id="浏览器的多进程">浏览器的多进程</h2><p>我们可以通过谷歌浏览器的任务管理器看到详细的进程信息。</p><p><img src="/assets/20200110/%E4%BB%BB%E5%8A%A1%E7%AE%A1%E7%90%86%E5%99%A8.png" alt="任务管理器"></p><ul><li>上图中的1所示，当我们打开浏览器后，会创建以下主要进程：<ol><li>浏览器进程：仅一个，浏览器的主进程。负责浏览器界面显示、用户交互（网址栏输入、前进、后退等）、管理各个页面（创建和销毁进程）、将渲染进程得到的内存中的位图显示到屏幕上、文件存储等功能。</li><li>GPU进程：仅一个，用于3D绘制等，将开启了3D绘制的元素渲染由CPU转向GPU，即开启GPU加速。</li><li>网络进程：仅一个，负责页面的网络资源加载。</li><li>音频进程：仅一个，负责浏览器音频管理。</li><li>插件进程：每种类型的插件对应一个进程，仅当使用该插件时才创建。</li><li>渲染进程：默认一个页面对应一个渲染进程。负责页面渲染、脚本执行、事件处理等，排版引擎Blink和V8引擎都运行在该进程中。</li></ol></li><li>当打开页面（新窗口或新标签页）时，默认情况下会创建对应的一个渲染进程。</li><li>当打开的页面采用iframe框架引入其他页面，则iframe会独立成辅助框架，有自己的渲染进程（one tab more process）。<a href="https://blog.csdn.net/wangfeijiu/article/details/106609953">[详解]</a></li><li>上图中的2所示，在浏览器的优化机制下，会出现进程合并的情况（more tab one process）。<a href="https://blog.csdn.net/wangfeijiu/article/details/106609953">[详解]</a></li><li>服务类进程（网络进程、音频进程等）是常驻进程，该类进程结束后会立即重启或刷新页面时重启。</li></ul><h2 id="浏览器内核的多线程">浏览器内核的多线程</h2><p>浏览器运行时会创建多个进程，下面着重分析浏览器内核（渲染进程）中的多线程功能。</p><p><img src="/assets/20200110/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86.png" alt="浏览器基本原理"></p><p>上图所示，渲染进程中包含多个线程功能，其中GUI渲染线程和JS引擎线程为主线程，且他们是互斥运行的。主要的线程功能说明如下：</p><ol><li>GUI渲染线程：负责渲染浏览器界面，解析html、css，构建DOM树和Render树，布局和绘制等。界面的重绘和回流也是该线程执行。（如排版引擎Blink）</li><li>JS引擎线程：负责解析JS脚本并运行。（如V8引擎）</li><li>事件触发线程：辅助JS引擎，用于控制事件轮询。鼠标点击、Ajax请求、Promise等对应异步任务会被添加到该线程中，符合触发条件时，事件会被该线程添加到任务队列的末尾，等待JS引擎线程处理。</li><li>定时器触发线程：定时器setInterval和setTimeout所在的线程。JS引擎为单线程，任务队列处于阻塞线程状态会影响计时器的准确性。</li><li>异步Http请求线程：用于处理XMLHttpRequest，XMLHttpRequest在连接后是通过浏览器新开一个线程请求。用于XMLHttpRequest状态变更检测，产生状态变更事件并将事件添加到任务队列中。</li><li>Worker线程：JS引擎线程向浏览器进程申请创建一个子线程，该子线程完全由JS引擎主线程控制，存在渲染进程中，不能操作DOM。JS引擎线程与Worker线程间通过postMessage API进行特定方式通信。主要用于处理计算密集型计算的问题，防止JS引擎主线程阻塞，相当于给JS引擎开的外挂。<a href="https://juejin.cn/post/6844903566281457678?searchId=2024022108415665BA0314A911E7F149B8">[详解]</a></li></ol><h2 id="浏览器渲染过程">浏览器渲染过程</h2><p>在浏览器输入url后，浏览器会创建一个页面下载线程进行页面内容下载，下载后将页面内容通过RendererHost接口转交给渲染进程，然后开始浏览器的页面渲染流程。</p><p><img src="/assets/20200110/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E5%8E%9F%E7%90%86.png" alt="浏览器渲染原理"></p><ol><li>通过html文档解析模块构建<strong>DOM树</strong>。</li><li>通过CSS文档解析模块构建<strong>CSSOM树</strong>。</li><li>将DOM树和CSSOM树结合构建<strong>Render树</strong>。</li><li>根据渲染树计算每个可见元素的<strong>布局</strong>（Layout）。</li><li><strong>绘制</strong>Render树（Paint），绘制页面像素信息。</li><li>浏览器会将各层的信息发送给GPU，GPU会将各层<strong>合成</strong>（Composite），显示在屏幕上。</li></ol><p>以上步骤是一个渐进的过程，为了提高用户体验，渲染引擎试图尽可能快的把结果显示给最终用户。它不会等到所有HTML都被解析完才创建并布局渲染树。它会在从网络层获取文档内容的同时把已经接收到的局部内容先展示出来。</p><h2 id="浏览器中的JS运行机制">浏览器中的JS运行机制</h2><p>页面完成渲染后，JS通过事件循环机制在浏览器中运行。如下图所示：</p><p><img src="/assets/20200110/js%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E6%9C%BA%E5%88%B6.png" alt="JS事件循环机制"></p><ul><li>同步任务：指在主线程上排队依次执行的任务，只有前一个任务执行完毕，才能执行后一个任务。</li><li>异步任务：由主线程委托给分线程执行的任务，异步任务又分为宏任务和微任务。</li><li>宏任务：每次执行栈执行的代码就是一个宏任务。包括：script(整体代码)、setTimeout、setInterval、UI渲染、I/O、postMessage、MessageChannel、setImmediate(Node.js 环境)等其他宏任务。</li><li>微任务：当前宏任务执行结束后立即执行的任务。包括：Promise（.then、.catch、.finally）、MutaionObserver、process.nextTick(Node.js环境）等其他微任务。</li><li>任务队列：由事件触发线程管理着一个用于存储待执行异步回调的任务队列。任务队列又分为宏任务队列和微任务队列，分别存储管理上述所说的宏任务和微任务。</li></ul><p><img src="/assets/20200110/%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E6%B5%81%E7%A8%8B%E5%9B%BE.png" alt="JS事件循环流程图"></p><p>上图所示，JS事件循环过程为：</p><ol><li>执行一个宏任务（执行栈中没有就从事件队列中获取）。</li><li>执行过程中如果遇到微任务，就将它添加到微任务的任务队列中。</li><li>宏任务执行完毕后，立即执行当前微任务队列中的所有微任务（依次执行）。</li><li>当前宏任务执行完毕，开始检查渲染，然后GUI线程接管渲染。</li><li>渲染完毕后，JS线程继续接管，开始下一个宏任务（从事件队列中获取）。</li></ol><h2 id="浏览器垃圾回收机制"><a href="https://juejin.cn/post/6981588276356317214?searchId=20240221135752B561C0E867F204196F41#heading-0">浏览器垃圾回收机制</a></h2><h3 id="垃圾回收策略">垃圾回收策略</h3><p>常见的垃圾回收策略有：</p><ul><li>分代式垃圾回收机制：将堆内存分为新生代和老生代两区域，采用不同的垃圾回收器也就是不同的策略管理垃圾回收。（V8引擎对垃圾回收机制的优化）。</li><li>标记清除算法：标记阶段把所有活动对象做上标记，清除阶段把没有标记的（非活动）对象销毁。</li><li>引用计数算法（已很少使用）：对象进行引用计数，将引用数为0的对象进行垃圾回收。</li></ul><p>参考链接：<a href="https://blog.csdn.net/wangfeijiu/article/details/106563082">剖析浏览器中的进程与线程</a>、<a href="https://juejin.cn/post/6844903553795014663#heading-17">从浏览器多进程到JS单线程，JS运行机制最全面的一次梳理</a></p>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 浏览器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>认证授权技术小结</title>
      <link href="/yiyuanqian_blog/2019/12/19/%E8%AE%A4%E8%AF%81%E6%8E%88%E6%9D%83%E6%8A%80%E6%9C%AF%E5%B0%8F%E7%BB%93/"/>
      <url>/yiyuanqian_blog/2019/12/19/%E8%AE%A4%E8%AF%81%E6%8E%88%E6%9D%83%E6%8A%80%E6%9C%AF%E5%B0%8F%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>在app使用过程中，认证是指app对用户身份进行验证，如账号密码登录、验证码登录、手机短信登录等各种登录认证方式；授权是指<strong>已认证</strong>的用户对第三方（app或用户）授予访问某些资源的权限，如用户授予App访问本机资源的权限、用户授予第三方App访问已认证App的个人信息的权限（QQ第三方app授权）等。由于HTTP是无状态协议，所以在认证授权的过程中，服务器端给客户端生成凭证（SessionID、Token、证书）的方式表明用户的合法身份，同时也维护了服务器端与客户端的会话状态。需要注意的是，这里讨论的认证是针对用户，授权是针对App。</p><h2 id="Session">Session</h2><p>Session是一种记录服务器端和客户端会话状态的机制，通过该机制可以实现服务器端对用户的认证授权。<br><img src="/assets/20191219/Session%E8%AE%A4%E8%AF%81%E6%9C%BA%E5%88%B6.png" alt="Session认证机制"></p><ul><li>Session认证机制是基于Cookie实现的，服务器端生成的SessionID发送到浏览器端以Cookie的形式进行存储，再次请求时自动携带该Cookie返回到服务器端。为了提高安全性，该Cookie可以设置为HttpOnly，禁止通过JS访问该Cookie。</li><li>Session生成时默认存储在服务器端内存中，为了防止服务器重启导致Session丢失，会对Session进行持久化存储（数据库）。</li><li>Session的生命周期完全由服务器端控制，服务器端可以对Session有效期进行控制。</li><li>由于Cookie不能跨域，所以Session机制只适合同域名下的用户认证。</li><li>移动端app不支持Cookie，所以基于Cookie的Session认证机制不可用。</li><li>不利于与其他网站或第三方app的数据资源共享。</li></ul><h2 id="Token">Token</h2><p><img src="/assets/20191219/Token%E8%AE%A4%E8%AF%81%E6%9C%BA%E5%88%B6.png" alt="Token认证机制"></p><ul><li>基于 Token 的用户认证是一种服务端无状态的认证方式，服务端不用存放 Token 数据。用解析Token的计算时间换取Session的存储空间，从而减轻服务器的压力，减少频繁的查询数据库。</li><li>Token完全由应用管理，所以它可以避开同源策略。</li><li>不依赖于Cookie，更适用于移动应用的用户认证。</li><li>（不足）由于Token在服务器端是无状态的，所以无法在使用过程中废止某个Token，或者更改Token的权限。</li></ul><h2 id="JWT"><a href="https://link.juejin.cn/?target=https%3A%2F%2Fwww.ruanyifeng.com%2Fblog%2F2018%2F07%2Fjson_web_token-tutorial.html">JWT</a></h2><p>JWT是目前最流行的跨域认证解决方案。可以简单理解为就是基于JSON结构的规范化Token。JWT包含了上述Token所说的特点，而上述最后一点的不足也是有解决方案的，可以点击<a href="https://www.jianshu.com/p/31b57201312d">这里</a>进行了解。</p><h2 id="SSO"><a href="https://juejin.cn/post/6844903509272297480?searchId=202403041651539446BE680EB7D4236BE0">SSO</a></h2><p>单点登录（SSO）是指在接入SSO系统的应用群中登陆一个系统后，访问应用群中的其他系统都会自动认证授权无需再次登录。在方案实现的过程中，将登陆功能抽取为独立的一个系统（SSO），其他系统请求SSO进行认证登陆。</p><h2 id="OAuth2-0"><a href="https://juejin.cn/post/6847009773477429255?searchId=202403041706416BA4C60E26D8C914039E">OAuth2.0</a></h2><p>OAuth2.0是一种开放授权机制，可以允许第三方应用在不使用账号和密码的情况下访问特定资源。例如：访问某网站想留言但又不想进行繁琐的注册操作，如果该网站提供QQ授权登录功能，就可以使用QQ进行授权登录，使用QQ的个人信息进行留言。</p><p>OAuth2.0的四种授权方式：</p><ol><li>授权码（最常用）：通过 client_id 、client_secret、code（授权码）获取 access_token。</li><li>隐藏式（纯前端）：直接通过 client_id 获取 access_token。</li><li>密码式（高度信任应用）：通过授权应用的username、password、client_id 获取 access_token。</li><li>凭证式（命令行应用）：通过 client_id 、client_secret 获取 access_token。</li></ol><h2 id="总结">总结</h2><p>Session、JWT、SSO、OAuth2.0 都是为了解决某一应用场景问题的解决方案。其中，Session、JWT、SSO更倾向于用户认证，OAuth2.0更倾向于授权允许第三方应用在不使用账号密码的情况下访问特定资源（当然授权的前提是用户已经合法认证）。</p><p>参考资料：<a href="https://juejin.cn/post/6844904034181070861">Cookie、Session、Token、JWT</a>、<a href="https://www.cnblogs.com/ywlaker/p/6113927.html">单点登录原理与简单实现</a>、<a href="https://www.jianshu.com/p/31b57201312d">JWT【关于刷新和作废的思考】</a></p>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 认证授权 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
